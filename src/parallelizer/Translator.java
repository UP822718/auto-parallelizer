package parallelizer;

import gen.CPPLexer;
import gen.CPPParser;
import org.antlr.v4.runtime.*;
import org.antlr.v4.runtime.misc.Interval;
import org.antlr.v4.runtime.tree.ParseTree;
import parallelizer.model.Function;
import parallelizer.model.Program;
import visitors.CallGraphVisitor;
import visitors.FunctionVisitor;
import visitors.GlobalVisitor;

import java.io.*;
import java.util.*;

/**
 * Created by milderhc on 12/05/17.
 */
public class Translator {

    public static Program program;

    public static final String OUTPUT_CODE_FOLDER = "output-code";

    private void visitFunctions (CPPParser parser) {
        parser.reset();
        ParseTree tree = parser.cpp();
        FunctionVisitor visitor = new FunctionVisitor(program);
        visitor.visit(tree);
    }

    private void buildCallGraph (CPPParser parser) {
        parser.reset();
        ParseTree tree = parser.cpp();
        CallGraphVisitor visitor = new CallGraphVisitor(program);
        visitor.visit(tree);
    }

    private LinkedList<Function> topoSort () {
        Queue<Function> q = new LinkedList<>();
        Map<Function, Integer> degree = new TreeMap<>();
        program.getCallGraph().forEach((f, list) -> degree.put(f, 0));
        program.getCallGraph().forEach((f, list) ->
            list.forEach(current -> degree.put(current, degree.get(current) + 1)));
        program.getCallGraph().forEach((f, list) -> {
            if (degree.get(f) == 0)
                q.add(f);
        });

        LinkedList<Function> order = new LinkedList<>();
        while (!q.isEmpty()) {
            Function f = q.poll();
            order.push(f);
            program.getCallGraph().get(f).forEach(current -> {
                degree.put(current, degree.get(current) - 1);
                if (degree.get(current) == 0)
                    q.add(current);
            });
        }

        return order;
    }

    private void deadCodeElimination (Function current,
                                                        Set<Function> visited, LinkedList<Function> newOrder) {
        visited.add(current);
        program.getCallGraph().get(current).forEach(neigh -> {
            if (!visited.contains(neigh))
                deadCodeElimination(neigh, visited, newOrder);
        });
        newOrder.add(current);
    }

    private LinkedList<Function> deadCodeElimination (LinkedList<Function> order) {
        Set<Function> visited = new TreeSet<>();
        LinkedList<Function> newOrder = new LinkedList<>();

        order.forEach(f -> {
            if (f.getId().equals("main"))
                deadCodeElimination(f, visited, newOrder);
        });

        return newOrder;
    }

    private void findDependencies(LinkedList<Function> functionsOrder ) {
        functionsOrder.forEach( f -> f.findDependencies() );
    }

    private void buildDependencyGraph(LinkedList<Function> functionsOrder) {
        functionsOrder.forEach( f -> f.buildDependencyGraph() );
    }

    private void findIslands(LinkedList<Function> functionsOrder) {
        functionsOrder.forEach( f -> f.findIslands() );
    }

    private final String credits = "/**\n" +
            "* Generated by Auto Parallelizer\n" +
            "*\n" +
            "* Auto Parallelizer supports Task parallelization and reduction recognition\n" +
            "* in for statements\n" +
            "*\n" +
            "* For further information see the -help of the executable file or \n" +
            "* the source code at https://github.com/milderhc/auto-parallelizer\n" +
            "*\n" +
            "* Developed by:\n" +
            "* Milder Hernandez Cagua\n" +
            "* Daniel Augusto Caceres Salas\n" +
            "*\n" +
            "* Universidad Nacional de Colombia\n" +
            "* May 2017\n" +
            "*\n" +
            "*/\n\n";

    private void addGlobalStatements (CPPParser parser) {
        parser.reset();
        program.add(credits);
        program.add("#include <omp.h>\n");
        TokenStream inputStream = parser.getInputStream();
        for (int i = 0; i < inputStream.size(); ++i) {
            Token token = inputStream.get(i);
            if (token.getChannel() == 1) {
                program.add(token.getText() + "\n");
            }
        }

        parser.reset();
        ParseTree tree = parser.cpp();
        GlobalVisitor visitor = new GlobalVisitor(program);
        visitor.visit(tree);
    }

    private void parallelize(LinkedList<Function> functionsOrder, boolean reduction) {
        functionsOrder.forEach( f -> program.add(f.parallelize(reduction)) );
    }

    public void translate (String inputFilename, String outputFilename, boolean reduction, boolean verbose) throws IOException {
        ANTLRInputStream input = new ANTLRInputStream(new FileInputStream(inputFilename));

        CPPLexer lexer = new CPPLexer(input);
        CommonTokenStream tokens = new CommonTokenStream(lexer);
        CPPParser parser = new CPPParser(tokens);

        program = new Program();

        visitFunctions(parser);
        buildCallGraph(parser);
        LinkedList<Function> functionsOrder = topoSort();

        if (verbose) {
            System.out.println("------- FUNCTIONS -------");
            System.out.println("List of functions of the source code:");
            program.getDefinedFunctions().forEach((f, nothing) -> System.out.println(f));
            System.out.println("-------------------------\n");

            System.out.println("--------- CALL GRAPH ---------");
            program.getCallGraph().forEach((f, neigh) -> {
                System.out.println("From <" + f.getId() + "> is called:");
                neigh.forEach(n -> System.out.println("-> " + n.getId()));
            });
            System.out.println("------------------------------\n");

            System.out.println("-------- FUNCTIONS ORDER --------");
            System.out.println("This is the order in which the functions are printed in the output file.\n");
            functionsOrder.forEach(current -> System.out.println(current.getId()) );
            System.out.println("---------------------------------\n");
        }

        functionsOrder.forEach( f -> {
            f.buildFlowGraph();
        });

        findDependencies(functionsOrder);
        functionsOrder = deadCodeElimination(functionsOrder);
        buildDependencyGraph(functionsOrder);
        findIslands(functionsOrder);

        if (verbose) {
            System.out.println("--------- FLOW GRAPHS ------------");
            System.out.println("A flow graph for every function (after dead code elimination is executed):");
            System.out.println("This includes a set of dead and alive variables for each block of instructions" +
                    "of every function:");
            functionsOrder.forEach( f -> {
                System.out.println("Function " + f.getId() );
                System.out.println("FLOW GRAPH: ");
                f.printFlowGraph();
            });
            System.out.println("----------------------------------\n");

            System.out.println("-------------- DEPENDENCY GRAPHS -------------");
            System.out.println("A dependency graph of blocks is printed for every function");
            functionsOrder.forEach( f -> {
                System.out.println("Function " + f.getId());
                System.out.println("DEPENDENCY GRAPH: ");
                f.printDependencyGraph();
            });
            System.out.println("----------------------------------------------\n");

            System.out.println("---------------- BLOCKS ORDER ----------------");
            System.out.println("After finding dependencies in the program and the islands of dependencies a new order of blocks is found\n");
            System.out.println("This is the blocks order found for every function");
            functionsOrder.forEach(f -> {
                System.out.println("Function " + f.getId());
                System.out.println("BLOCKS ORDER");
                f.getBlocksOrder().forEach(block -> {
                    System.out.println(block.getKey().getId() + " in island " + block.getValue());
                });
                System.out.println();
            });
            System.out.println("----------------------------------------------\n");
        }

        addGlobalStatements(parser);

        parallelize(functionsOrder, reduction);
        exportCode(outputFilename);
    }

    public static String getText (ParserRuleContext ctx) {
        int a = ctx.start.getStartIndex();
        int b = ctx.stop.getStopIndex();
        Interval interval = new Interval(a,b);
        return ctx.start.getInputStream().getText(interval) + "\n";
    }

    public void exportCode (String file) throws FileNotFoundException, UnsupportedEncodingException {
        printToFile(file, program.getTranslatedCode().toString());
    }

    public void printToFile (String filename, String s) throws FileNotFoundException, UnsupportedEncodingException {
        PrintWriter writer = new PrintWriter(filename, "UTF-8");
        writer.print(s);
        writer.close();
    }
}
